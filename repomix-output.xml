This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
coder/
  main.tf
  startup.sh
srv/
  deploy/
    deploy.sh
  docs/
    index.html
  nginx/
    nginx.conf
  pm2/
    ecosystem.config.js
  webhook/
    server.js
Dockerfile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="coder/main.tf">
terraform {
  required_providers {
    coder = {
      source = "coder/coder"
    }
    kubernetes = {
      source = "hashicorp/kubernetes"
    }
  }
}

# Setup Variables
# username is a shorthand for the owner.
# ixd_domain (is probably ixdcoder.com or sheridanixd.com)
# workspace_slug - 8 pseudo random characters derived from the id of the workspace
# this is used as part of the editor URL and makes it  difficult guess 
# note you could make this longer but  a subdomain string cannot be longer than 63 characters 
# so it is good to leave some space for the actual name of the project.

locals {
  username = data.coder_workspace_owner.me.name
  ixd_domain = "ixdcoder.com"
  workspace_slug = substr(md5(data.coder_workspace.me.id), 0, 8)
}

provider "coder" {
}

variable "use_kubeconfig" {
  type        = bool
  description = <<-EOF
  Use host kubeconfig? (true/false)

  Set this to false if the Coder host is itself running as a Pod on the same
  Kubernetes cluster as you are deploying workspaces to.

  Set this to true if the Coder host is running outside the Kubernetes cluster
  for workspaces.  A valid "~/.kube/config" must be present on the Coder host.
  EOF
  default     = false
}

variable "namespace" {
  type        = string
  description = "The Kubernetes namespace to create workspaces in (must exist prior to creating workspaces). If the Coder host is itself running as a Pod on the same Kubernetes cluster as you are deploying workspaces to, set this to the same namespace."
}
 
 

data "coder_parameter" "git_repo" {
  name                = "git_repo"
  display_name        = "App #1 Git Repository"
  description = "URL for a Git Repository to deploy as a NodeJS app."
  icon        = "/icon/git.svg"
  type        = "string"
  mutable     = true
  default     = "https://bender.sheridanc.on.ca/sikkemha/nodejs.git" 
}

data "coder_parameter" "allowed_repos" {
  name         = "ALLOWED_REPOS"
  display_name = "Allowed GitHub repos (JSON array, owner/repo)"
  type         = "string"
  mutable      = true
  default      = "[\"owner/repo-a\",\"owner/repo-b\"]"
}
 



  

provider "kubernetes" {
  # Authenticate via ~/.kube/config or a Coder-specific ServiceAccount, depending on admin preferences
  config_path = var.use_kubeconfig == true ? "~/.kube/config" : null
}
 
data "coder_workspace" "me" {}

# NOTE: the workspace owner details were previously included in coder_workspace.owner
# but those params are now deprecated in favour of "coder_workspace_owner"
data "coder_workspace_owner" "me" {} 

resource "coder_agent" "main" {
  os                     = "linux"
  arch                   = "amd64" 
  startup_script         = replace(file("${path.module}/startup.sh"), "\r", "")
 
  # TEST: this may help to tell VS Code Desktop which folder to open
  dir  = "/home/coder/${data.coder_workspace_owner.me.name}"

  display_apps {
    vscode          = false
    vscode_insiders = false
    web_terminal    = false
    ssh_helper      = false
  }

   
  env = {
    GIT_AUTHOR_NAME     = "${data.coder_workspace_owner.me.name}"
    GIT_COMMITTER_NAME  = "${data.coder_workspace_owner.me.name}"
    GIT_AUTHOR_EMAIL    = "${data.coder_workspace_owner.me.email}"
    GIT_COMMITTER_EMAIL = "${data.coder_workspace_owner.me.email}" 
    GIT_REPO            = "${data.coder_parameter.git_repo.value}" 
    WORKSPACE_NAME      = "${data.coder_workspace.me.name}"
    WORKSPACE_ID        = "${data.coder_workspace.me.id}"
    PUBLIC_URL          = "https://public--main--${lower(data.coder_workspace.me.name)}--${local.username}.${local.ixd_domain}/"
    EDITOR_URL          = "https://${local.workspace_slug}--main--${lower(data.coder_workspace.me.name)}--${local.username}.${local.ixd_domain}/"
    SETTINGS_URL        = "https://${local.ixd_domain}/@${local.username}/${data.coder_workspace.me.name}"
    USERNAME            = "${local.username}"
    # TEMPLATE_MODE       = "${data.coder_parameter.template_mode.value}"
    PORT                = 8080   

    ALLOWED_REPOS          = "${data.coder_parameter.allowed_repos.value}" 
    DEFAULT_BRANCH         = "main" 

  }
 
 
}
# It is vital that the workspace folder in the url 
# Matches the folder that we are actually persisting. 
# /home/coder/${data.coder_workspace_owner.me.name}

# NOTE coder modules are frequently updated. 
# note that version  = "1.0.30" refers to the entire module repo rather than the specific module
# you can see a complete history of module changes here:/
# https://github.com/coder/modules/compare/v1.0.6...v1.0.30
# See also, more specifically:
# https://github.com/coder/modules/commits/main/cursor
# https://github.com/coder/modules/commits/main/vscode-web

 

module "vscode-web" {
  source         = "registry.coder.com/modules/vscode-web/coder"
  version        = "1.0.30"
  agent_id       = coder_agent.main.id
  folder   = "/home/coder/${data.coder_workspace_owner.me.name}"
  # extensions     = ["github.copilot"]
  settings = {
      "workbench.colorTheme": "Default Dark Modern",
      "workbench.colorCustomizations": {
          "statusBar.background" : "#1A1A1A",
          "statusBar.noFolderBackground" : "#212121",
          "statusBar.debuggingBackground": "#263238"
      },
      "files.exclude": {
          "**/*.cache": true,
          "**/*.config": true,
          "**/*.local": true,
          "**/*.bashrc": true,
          "**/*.npm": true,
          "**/*filebrowser.db": true,
          "**/*lost+found": true,
          "**/*.bash_history": true,
          "**/*.vscode": true,
          "**/*.dotnet": true,
          "**/*.vscode-server": true,
          "**/*.wget-hsts": true
      },
      "workbench.startupEditor" : "readme",
      "security.workspace.trust.enabled": false,
      "editor.defaultFormatter": "esbenp.prettier-vscode",
      "codetogether.userName": "${local.username}",
      "remote.portsAttributes": {
          "0-65535":{
              "onAutoForward":"silent"
          }
      },
      "remote.SSH.remotePlatform": {
          "*.ixdcoder.com": "linux",
      }
  } 
  accept_license = true
}
 
  

resource "coder_app" "webapp" {
  agent_id     = coder_agent.main.id
  slug         = "public"
  display_name = "Public URL"
  url          = "http://localhost:8080"
  icon         = "https://bender.sheridanc.on.ca/sikkemha/svg-icons/-/raw/main/html.svg"
  subdomain    = true
  share        = "public"
  healthcheck {
    # Note: this health check assumes that LiveServer is running,
    # as indeed it should be based on startup.sh
    url       = "http://localhost:8080"
    interval  = 5
    threshold = 6
  }
}

 
# NOTE: the storage amount is hard coded to 1Gigabyte here
# this is different from the NodeJS workspace, where it is parameterized.
resource "kubernetes_persistent_volume_claim" "home" {
  metadata {
    name      = "coder-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}-home" 
    namespace = var.namespace
    labels = {
      "app.kubernetes.io/name"     = "coder-pvc"
      "app.kubernetes.io/instance" = "coder-pvc-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}" 
      "app.kubernetes.io/part-of"  = "coder"
      //Coder-specific labels.
      "com.coder.resource"       = "true"
      "com.coder.workspace.id"   = data.coder_workspace.me.id
      "com.coder.workspace.name" = data.coder_workspace.me.name
      "com.coder.user.id"        = data.coder_workspace_owner.me.id
      "com.coder.user.username"  = data.coder_workspace_owner.me.name
    }
    annotations = {
      "com.coder.user.email" = data.coder_workspace_owner.me.email
    }
  }
  wait_until_bound = false
  spec {
    access_modes = ["ReadWriteOnce"]
    resources {
      requests = {
        storage = "512Mi"
      }
    }
  }
}

resource "kubernetes_deployment" "main" {
  count = data.coder_workspace.me.start_count
  depends_on = [
    kubernetes_persistent_volume_claim.home
  ]
  wait_for_rollout = false
  metadata {
    name      = "coder-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}" 
    namespace = var.namespace
    labels = {
      "app.kubernetes.io/name"     = "coder-workspace"
      "app.kubernetes.io/instance" = "coder-workspace-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}"
      "app.kubernetes.io/part-of"  = "coder"
      "com.coder.resource"         = "true"
      "com.coder.workspace.id"     = data.coder_workspace.me.id
      "com.coder.workspace.name"   = data.coder_workspace.me.name
      "com.coder.user.id"          = data.coder_workspace_owner.me.id
      "com.coder.user.username"    = data.coder_workspace_owner.me.name
    }
    annotations = {
      "com.coder.user.email" = data.coder_workspace_owner.me.email
    }
  }

  spec {
    # replicas = data.coder_workspace.me.start_count
    replicas = 1
    selector {
      match_labels = {
        "app.kubernetes.io/name" = "coder-workspace"
      }
    }
    strategy {
      type = "Recreate"
    }

    template {
      metadata {
        labels = {
          "app.kubernetes.io/name" = "coder-workspace"
        }
      }
      spec {
        security_context {
          run_as_user = 1000
          fs_group    = 1000
        }

        container {
          name              = "dev"
          # image             = "codercom/enterprise-node:ubuntu"
          # image             = "nsitu/node-devenv-2024:latest"
          image  = "nsitu/coder-pm2-paas:latest"
          # Image Pull Policy: Always / IfNotPresent/ Never
          # see also: https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy 
          image_pull_policy = "Always"
          command           = ["sh", "-c", coder_agent.main.init_script]
          security_context {
            run_as_user = "1000"
          }
          # TODO: maybe it is convenient to inject other env variables here?
          env {
            name  = "CODER_AGENT_TOKEN"
            value = coder_agent.main.token
          }
          resources {
            requests = {
              "cpu"    = "250m"
              "memory" = "512Mi"
            }
            limits = {
              "cpu"    = "1000m"
              "memory" = "2Gi"
            }
          }
          volume_mount {
            # IMPORTANT the mount path determines which files are persisted 
            # ie. saved between restarts.  
            mount_path = "/home/coder"
            name       = "home"
            read_only  = false
          }
        }

        volume {
          name = "home"
          persistent_volume_claim {
            claim_name = kubernetes_persistent_volume_claim.home.metadata.0.name
            read_only  = false
          }
        }

        affinity {
          // This affinity attempts to spread out all workspace pods evenly across
          // nodes.
          pod_anti_affinity {
            preferred_during_scheduling_ignored_during_execution {
              weight = 1
              pod_affinity_term {
                topology_key = "kubernetes.io/hostname"
                label_selector {
                  match_expressions {
                    key      = "app.kubernetes.io/name"
                    operator = "In"
                    values   = ["coder-workspace"]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
</file>

<file path="coder/startup.sh">
set -e  
# set -e instructs the shell to immediately exit 
# if any command within the script returns a non-zero status (which genera# --- Opt# ---pm2 save || true


# Standardize base path for all services
BASE="/home/coder/srv"


# Deploy once if no apps yet and GIT_REPO provided (useful for a demo or "App #1" param)
if [ ! -s "$BASE/deploy/ports.map" ] && [ -n "${GIT_REPO:-}" ]; then
  # Derive repo name from URL (handles ssh/https common cases)
  REPO_NAME="$(basename -s .git "$(echo "$GIT_REPO" | sed 's#.*[:/]\([^/]*\)\.git$#\1#')")"
  "$BASE/deploy/deploy.sh" "$REPO_NAME" "$GIT_REPO" "${DEFAULT_BRANCH:-main}" || echo "initial deploy failed"
  pm2 save || true
first-boot auto-deploy ---
# Deploy once if no apps yet and GIT_REPO provided (useful for a demo or "App #1" param)
if [ ! -s "$BASE/deploy/ports.map" ] && [ -n "${GIT_REPO:-}" ]; then
  # Derive repo name from URL (handles ssh/https common cases)
  REPO_NAME="$(basename -s .git "$(echo "$GIT_REPO" | sed 's#.*[:/]\([^/]*\)\.git$#\1#')")"
  "$BASE/deploy/deploy.sh" "$REPO_NAME" "$GIT_REPO" "${DEFAULT_BRANCH:-main}" || echo "initial deploy failed"
  pm2 save || true
ficates an error)


# Create the project directory if it doesn't exist
# assign coder as the owner of the project directory
# Navigate to the workspace directory 
mkdir -p ~/${USERNAME}
sudo chown coder:coder ~/${USERNAME}
cd ~/${USERNAME}
 
# Check the value of CODE_TEMPLATE
# Set the GIT_REPO to the default value if CODE_TEMPLATE is "default"
# Leave GIT_REPO as it is if CODE_TEMPLATE is anything else. (e.g "custom" or blank.) 
if [ "$CODE_TEMPLATE" = "default" ]; then 
    GIT_REPO="https://bender.sheridanc.on.ca/sikkemha/html-css-js"  
fi
  
echo "Public URL: ${PUBLIC_URL}" 
echo "Editor URL: ${EDITOR_URL}" 
echo "Settings URL: ${SETTINGS_URL}" 
echo "Code Template: ${CODE_TEMPLATE}"
echo "Boilerplate Git Repository: '${GIT_REPO}'"
echo "PORT is: ${PORT}" 
echo "Current Directory is: $PWD" 
 

# This is where we should call the deploy script.  
 
echo Customizing the shell appearance for simplicity
echo 'export PS1="\\[\\033[01;34m\\]\\w\\[\\033[00m\\] $ "' >> ~/.bashrc 

# Let's Get the Public IP Address of the Workspace
# NOTE: I found that opendns, google, etc. are not reliable in the workspace. 
# The following should work but does not.
# echo "Public IP Address: $(dig +short myip.opendns.com @resolver1.opendns.com)"
# Perhaps this is due to DNS or Network settings. 
# Instead we can use a variety of public IP services, here's a list,
# We will pick one randomly and if it doesn't work we will pick a different one.

services=(
  "https://ipinfo.io/ip"
  "https://api.ipify.org"
  "https://checkip.amazonaws.com"
  "https://ifconfig.me/ip"
  "https://ipapi.co/ip"
  "https://icanhazip.com/"
  "https://ident.me"
  "https://myexternalip.com/raw"
  "https://whatismyip.akamai.com"
)

# Function to get public IP
get_public_ip() {
  for ((i=0; i<${#services[@]}; i++)); do
    # Randomly select a service
    service=${services[RANDOM % ${#services[@]}]}
    
    # Try to fetch public IP
    ip=$(curl -s --max-time 3 "$service")
    
    # If the result is non-empty, return it
    if [[ -n "$ip" ]]; then
      echo "Public IP Address: $ip"
      echo "(Fetched via $service)"
      return 0
    fi
  done
  echo "Unable to fetch Public IP Address."
  return 1
}
 

echo =========
echo "System Information Snapshot $(date '+%a %b %d %Y, %I:%M%p')"
echo ---------
get_public_ip
echo ---------
coder stat
echo ---------
echo "TIP: For an updated snapshot, try these commands on the terminal:"
echo "coder stat                # Get the current resource use"
echo "curl ipinfo.io/ip         # Get your current public IP Address"
echo "top                       # See what processes are running"
echo =========


# --- ensure /srv layout exists and files are in place ---
sudo mkdir -p "$BASE" && sudo chown -R coder:coder "$BASE"
sudo mkdir -p "$BASE"/{apps,deploy,docs,nginx/conf.d,pm2,webhook}

# If you baked these into the image under /srv/, great. If you copied to /opt/bootstrap,
# move them into place on first boot only:
if [ ! -f "$BASE/nginx/nginx.conf" ] && [ -d /opt/bootstrap/srv ]; then
  cp -r /opt/bootstrap/srv/* "$BASE"/
fi

# --- SSH key for webhook git clone (optional; only if you pass it as a secret) ---
# Expect GIT_SSH_PRIVATE_KEY and GIT_KNOWN_HOSTS from Coder secrets/params
if [ -n "${GIT_SSH_PRIVATE_KEY:-}" ]; then
  mkdir -p ~/.ssh && chmod 700 ~/.ssh
  printf '%s\n' "$GIT_SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
  chmod 600 ~/.ssh/id_ed25519
fi
# Pre-seed known_hosts for GitHub; or use your own forge
if [ -z "${GIT_KNOWN_HOSTS:-}" ]; then
  # Dynamically detect repo host from GIT_REPO and add to known_hosts
  REPO_HOST="$(echo "${GIT_REPO:-}" | sed -E 's#(git@|https?://)([^/:]+).*#\2#')"
  [ -n "$REPO_HOST" ] && ssh-keyscan "$REPO_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
else
  printf '%s\n' "$GIT_KNOWN_HOSTS" >> ~/.ssh/known_hosts
fi
chmod 644 ~/.ssh/known_hosts || true

# --- Nginx up (daemonized) ---
# Test and start/reload safely
nginx -t && (nginx -s reload || nginx) || { echo "Nginx config error"; exit 1; }

# --- PM2 bootstrap ---
export PM2_HOME="${PM2_HOME:-$BASE/.pm2}"
pm2 ping >/dev/null 2>&1 || true
# If we have a previous dump, restore all apps (including webhook)
if [ -f "$PM2_HOME/dump.pm2" ]; then
  pm2 resurrect || true
fi

# Ensure the webhook process is running (safe to re-run)
if ! pm2 describe webhook >/dev/null 2>&1; then
  pm2 start "$BASE/pm2/ecosystem.config.js" --only webhook || pm2 start "$BASE/pm2/ecosystem.config.js"
fi
pm2 save || true

# --- Optional first-boot auto-deploy ---
# Deploy once if no apps yet and GIT_REPO provided (useful for a demo or "App #1" param)
if [ ! -s "$BASE/deploy/ports.map" ] && [ -n "${GIT_REPO:-}" ]; then
  # Derive repo name from URL (handles ssh/https common cases)
  REPO_NAME="$(basename -s .git "$(echo "$GIT_REPO" | sed 's#.*[:/]\([^/]*\)\.git$#\1#')")"
  "$BASE/deploy/deploy.sh" "$REPO_NAME" "$GIT_REPO" "${DEFAULT_BRANCH:-main}" || echo "initial deploy failed"
  pm2 save || true
fi

echo "Startup complete. Public URL: ${PUBLIC_URL}"rst-boot auto-deploy ---
</file>

<file path="srv/deploy/deploy.sh">
# /home/coder/srv/deploy/deploy.sh
#!/usr/bin/env bash
set -euo pipefail

REPO_NAME="${1:?repo name required}"
GIT_URL="${2:?git url required}"
BRANCH="${3:-main}"
BASE_PATH="/${REPO_NAME}"
BASE="/home/coder/srv"
APPS_DIR="$BASE/apps"
PORTS_FILE="$BASE/deploy/ports.map"
NGINX_CONF_DIR="$BASE/nginx/conf.d"
ECOSYSTEM="$BASE/pm2/ecosystem.config.js"

mkdir -p "$APPS_DIR" "$NGINX_CONF_DIR" "$BASE/docs"
touch "$PORTS_FILE" "$ECOSYSTEM"

APP_DIR="${APPS_DIR}/${REPO_NAME}"

# allocate a stable port per app
function get_port () {
  if grep -q "^${REPO_NAME}:" "$PORTS_FILE"; then
    awk -F: -v app="$REPO_NAME" '$1==app{print $2}' "$PORTS_FILE"
  else
    # find next free port starting at 3001
    PORT=3001
    while lsof -iTCP:$PORT -sTCP:LISTEN >/dev/null 2>&1 || grep -q ":$PORT$" "$PORTS_FILE"; do
      PORT=$((PORT+1))
    done
    echo "${REPO_NAME}:$PORT" >> "$PORTS_FILE"
    echo "$PORT"
  fi
}

PORT="$(get_port)"

# checkout/update
if [ -d "$APP_DIR/.git" ]; then
  git -C "$APP_DIR" fetch origin "$BRANCH" --depth=1
  git -C "$APP_DIR" checkout "$BRANCH"
  git -C "$APP_DIR" reset --hard "origin/$BRANCH"
else
  git clone --branch "$BRANCH" --depth=1 "$GIT_URL" "$APP_DIR"
fi

# install & build (skip build if not present)
if [ -f "$APP_DIR/package.json" ]; then
  cd "$APP_DIR"
  npm ci --omit=dev || npm install --omit=dev
  if jq -e '.scripts.build' package.json >/dev/null 2>&1; then
    npm run build
  fi
fi

# nginx location for this app
cat > "${NGINX_CONF_DIR}/${REPO_NAME}.conf" <<EOF
location ^~ ${BASE_PATH}/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade \$http_upgrade;
  proxy_set_header Connection \$connection_upgrade;
  proxy_set_header X-Forwarded-Prefix ${BASE_PATH};
  proxy_set_header X-Forwarded-Host \$host;
  rewrite ^${BASE_PATH}/(.*)\$ /\$1 break;
  proxy_pass http://127.0.0.1:${PORT};
}
EOF

# ensure pm2 app entry exists/updated
node - <<'EOF'
const fs=require('fs');
const path=process.env.ECOSYSTEM;
let mod={apps:[]};
if (fs.existsSync(path)) { mod=require(path); }
mod.apps = mod.apps.filter(a=>a.name!=="__REPO__");
mod.apps.push({
  name:"__REPO__",
  script:"npm",
  args:"start",
  cwd:"__CWD__",
  env:{ PORT:"__PORT__", BASE_PATH:"/__REPO__" },
  max_memory_restart:"250M",
  instances:1,
  exec_mode:"fork",
  restart_delay:2000
});
fs.writeFileSync(path, "module.exports="+JSON.stringify(mod,null,2));
EOF
# replace placeholders
sed -i "s#__REPO__#${REPO_NAME}#g;s#__CWD__#${APP_DIR}#g;s#__PORT__#${PORT}#g" "$ECOSYSTEM"

# reload services
nginx -t
nginx -s reload || nginx -s reopen

pm2 start "$ECOSYSTEM"
pm2 reload "${REPO_NAME}" || true
pm2 save
</file>

<file path="srv/docs/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>PaaS Server for NodeJS Apps</title>
</head>

<body>
    <h1>PaaS Server for NodeJS Apps</h1>
    <p>Powered by PM2 and NGINX</p>
</body>

</html>
</file>

<file path="srv/nginx/nginx.conf">
# /home/coder/srv/nginx/nginx.conf
worker_processes 1;

events { worker_connections 1024; }

http {
  sendfile on;
  include       mime.types;
  default_type  application/octet-stream;

  # WS support
  map $http_upgrade $connection_upgrade { default upgrade; '' close; }

  # Useful when apps need original host/path
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  server {
    listen 8080;

    # Documentation landing page
    location = / {
      root /home/coder/srv/docs;
      try_files /index.html =404;
    }
    # GitHub webhook for app deployments
    location = /__hook/github {
      proxy_pass http://127.0.0.1:4600/webhook/github;
      proxy_http_version 1.1;
      # optional hardening:
      # if ($request_method != POST) { return 405; }
      # limit_req zone=gh burst=10 nodelay;
    }


    # Normalize trailing slashes so /repo and /repo/ both work
    rewrite ^/([^/]+)$ /$1/ permanent;

    # Per-app routes live here:
    include /home/coder/srv/nginx/conf.d/*.conf;
  }
}
</file>

<file path="srv/pm2/ecosystem.config.js">
// /srv/pm2/ecosystem.config.js
module.exports = {
    apps: [
        {
            name: "webhook",
            script: "node",
            args: "/home/coder/srv/webhook/server.js",
            env: {
                WEBHOOK_PORT: "4600"
            }
        }

        // Entries appended by deploy script, e.g.:
        // {
        //   name: "repo-name",
        //   script: "npm",
        //   args: "start",
        //   cwd: "/srv/apps/repo-name",
        //   env: {
        //     PORT: 3001,
        //     BASE_PATH: "/repo-name"
        //   },
        //   max_memory_restart: "250M",
        //   instances: 1,
        //   exec_mode: "fork",
        //   restart_delay: 2000
        // }
    ]
}
</file>

<file path="srv/webhook/server.js">
// /srv/webhook/server.js
const crypto = require('crypto');
const express = require('express');
const { spawn } = require('child_process');

const app = express();
app.use(express.json({ type: '*/*' })); // GitHub sends various content-types

const SECRET = process.env.GITHUB_WEBHOOK_SECRET || '';
const ALLOWED_REPOS = JSON.parse(process.env.ALLOWED_REPOS || '[]'); // ["owner/repo"]
const ALLOWED_BRANCHES = JSON.parse(process.env.ALLOWED_BRANCHES || '["main"]');
const DEPLOY = process.env.DEPLOY_SCRIPT || '/srv/deploy/deploy.sh';
const DEPLOYED_SHAS = new Set(); // simple in-memory dedupe (survives while workspace runs)

function matchesBranch(ref) {
    // ref like "refs/heads/main"
    const br = ref.replace(/^refs\/heads\//, '');
    return ALLOWED_BRANCHES.some(pat => {
        if (pat.endsWith('/*')) return br.startsWith(pat.slice(0, -2));
        return br === pat;
    });
}

function verifySig(req) {
    const sig = req.get('x-hub-signature-256') || '';
    if (!SECRET || !sig.startsWith('sha256=')) return false;
    const hmac = crypto.createHmac('sha256', SECRET);
    const payload = JSON.stringify(req.body);
    const digest = 'sha256=' + hmac.update(payload).digest('hex');
    // constant-time compare
    return crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(digest));
}

function runDeploy(repoName, gitUrl, branch) {
    return new Promise((resolve, reject) => {
        // simple lock per repoName using a dotfile
        const lock = spawn('bash', ['-lc', `
      set -e
      LOCK="/tmp/deploy_${repoName}.lock"
      exec 9>"$LOCK"
      flock -n 9 || { echo "busy"; exit 99; }
      "${DEPLOY}" "${repoName}" "${gitUrl}" "${branch}"
    `], { stdio: ['ignore', 'pipe', 'pipe'] });

        let out = ''; let err = '';
        lock.stdout.on('data', d => out += d.toString());
        lock.stderr.on('data', d => err += d.toString());
        lock.on('close', code => {
            if (code === 0) resolve(out || 'ok');
            else if (code === 99) reject(new Error('deploy-in-progress'));
            else reject(new Error(err || `deploy failed (${code})`));
        });
    });
}

app.post('/webhook/github', async (req, res) => {
    try {
        if (!verifySig(req)) return res.status(401).json({ error: 'bad signature' });

        const event = req.get('x-github-event');
        if (event !== 'push') return res.status(202).json({ status: `ignored:${event}` });

        const repoFull = req.body?.repository?.full_name;   // "owner/repo"
        const branchRef = req.body?.ref;                    // "refs/heads/main"
        const afterSha = req.body?.after;
        if (!repoFull || !branchRef || !afterSha)
            return res.status(400).json({ error: 'missing fields' });

        if (!ALLOWED_REPOS.includes(repoFull))
            return res.status(403).json({ error: 'repo not allowed' });

        if (!matchesBranch(branchRef))
            return res.status(202).json({ status: 'ignored:branch' });

        if (DEPLOYED_SHAS.has(afterSha))
            return res.status(202).json({ status: 'ignored:duplicate' });

        // map repo name to subfolder & nginx location
        const repoName = repoFull.split('/')[1];
        const gitUrl = `git@github.com:${repoFull}.git`;
        await runDeploy(repoName, gitUrl, branchRef.replace('refs/heads/', ''));
        DEPLOYED_SHAS.add(afterSha);
        return res.json({ status: 'deployed', repo: repoName, sha: afterSha });
    } catch (e) {
        const code = e.message === 'deploy-in-progress' ? 429 : 500;
        return res.status(code).json({ error: e.message });
    }
});

const port = process.env.WEBHOOK_PORT || 4600;
app.listen(port, '127.0.0.1', () => {
    console.log(`webhook listening on ${port}`);
});
</file>

<file path="Dockerfile">
FROM ubuntu:noble

SHELL ["/bin/bash", "-c"]
ENV DEBIAN_FRONTEND=noninteractive

# Install packages
RUN apt-get update && \
    apt-get upgrade --yes --no-install-recommends --no-install-suggests && \
    apt-get install --yes --no-install-recommends --no-install-suggests \
    ca-certificates \
    bash \
    build-essential \ 
    curl \ 
    htop \
    jq \
    locales \
    man \
    pipx \
    python3 \
    python3-pip \
    software-properties-common \
    sudo \
    # systemd \
    # systemd-sysv \
    unzip \
    zip \
    vim \
    wget \
    net-tools \
    dnsutils \
    tzdata \
    rsync \ 
    openssh-client \
    lsof \
    util-linux \
    nginx && \ 
    # Install latest Git using their official PPA
    add-apt-repository ppa:git-core/ppa && \
    apt-get install --yes git \
    && rm -rf /var/lib/apt/lists/*

# Pre-seed GitHub known_hosts to avoid first-clone prompts (optional):
RUN mkdir -p /home/coder/.ssh && ssh-keyscan github.com >> /home/coder/.ssh/known_hosts && chown -R coder:coder /home/coder/.ssh


# Install whichever Node version is LTS 
RUN curl -sL https://deb.nodesource.com/setup_lts.x | bash -
RUN DEBIAN_FRONTEND="noninteractive" apt-get update -y && \
    apt-get install -y nodejs 

# Latest NPM 
RUN npm install -g npm@latest --verbose

# Install pm2
RUN npm install pm2 -g

# Generate the desired locale (en_US.UTF-8)
RUN locale-gen en_US.UTF-8

# Set Timezone
ENV TZ="America/Toronto"

# Make typing unicode characters in the terminal work.
ENV LANG=en_US.UTF-8
ENV LANGUAGE=en_US.UTF-8
ENV LC_ALL=en_US.UTF-8

# Remove the `ubuntu` user and add a user `coder` so that you're not developing as the `root` user
RUN userdel -r ubuntu && \
    useradd coder \
    --create-home \
    --shell=/bin/bash \ 
    --uid=1000 \
    --user-group && \
    echo "coder ALL=(ALL) NOPASSWD:ALL" >>/etc/sudoers.d/nopasswd

# Copy system files to seed the container
COPY --chown=coder:coder srv/ /opt/bootstrap/srv/



USER coder
RUN pipx ensurepath # adds user's bin directory to PATH
</file>

<file path="README.md">
# coder-pm2-paas
Docker image for Coder with PM2 Node and NGINX

# srv folder
this folder includes structure that is used to manage deployments 

# coder folder
this folder holds coder workspace configuration files
</file>

</files>
