This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
coder/
  main.tf
  startup.sh
srv/
  deploy/
    deploy.sh
  docs/
    index.html
  nginx/
    nginx.conf
  pm2/
    ecosystem.config.js
  webhook/
    package.json
    server.js
Dockerfile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="srv/deploy/deploy.sh">
# /home/coder/srv/deploy/deploy.sh
#!/usr/bin/env bash
set -euo pipefail

REPO_NAME="${1:?repo name required}"
GIT_URL="${2:?git url required}"
BRANCH="${3:-main}"
BASE_PATH="/${REPO_NAME}"
BASE="/home/coder/srv"
APPS_DIR="$BASE/apps"
PORTS_FILE="$BASE/deploy/ports.map"
NGINX_CONF_DIR="$BASE/nginx/conf.d"
ECOSYSTEM="$BASE/pm2/ecosystem.config.js"

mkdir -p "$APPS_DIR" "$NGINX_CONF_DIR" "$BASE/docs"
touch "$PORTS_FILE" "$ECOSYSTEM"

APP_DIR="${APPS_DIR}/${REPO_NAME}"

# allocate a stable port per app
get_port () {
  if grep -q "^${REPO_NAME}:" "$PORTS_FILE"; then
    awk -F: -v app="$REPO_NAME" '$1==app{print $2}' "$PORTS_FILE"
  else
    PORT=3001
    while lsof -iTCP:$PORT -sTCP:LISTEN >/dev/null 2>&1 || grep -q ":$PORT$" "$PORTS_FILE"; do
      PORT=$((PORT+1))
    done
    echo "${REPO_NAME}:$PORT" >> "$PORTS_FILE"
    echo "$PORT"
  fi
}
PORT="$(get_port)"

# checkout/update
if [ -d "$APP_DIR/.git" ]; then
  git -C "$APP_DIR" fetch origin "$BRANCH" --depth=1
  git -C "$APP_DIR" checkout "$BRANCH"
  git -C "$APP_DIR" reset --hard "origin/$BRANCH"
else
  git clone --branch "$BRANCH" --depth=1 "$GIT_URL" "$APP_DIR"
fi

# install & build
if [ -f "$APP_DIR/package.json" ]; then
  cd "$APP_DIR"
  npm ci --omit=dev || npm install --omit=dev
  if jq -e '.scripts.build' package.json >/dev/null 2>&1; then
    npm run build
  fi
fi

# nginx location
cat > "${NGINX_CONF_DIR}/${REPO_NAME}.conf" <<EOF
location ^~ ${BASE_PATH}/ {
  proxy_http_version 1.1;
  proxy_set_header Upgrade \$http_upgrade;
  proxy_set_header Connection \$connection_upgrade;
  proxy_set_header X-Forwarded-Prefix ${BASE_PATH};
  proxy_set_header X-Forwarded-Host \$host;
  rewrite ^${BASE_PATH}/(.*)\$ /\$1 break;
  proxy_pass http://127.0.0.1:${PORT};
}
EOF

# ensure pm2 app entry exists/updated (pass path via env explicitly)
NODE_ECOSYSTEM="$ECOSYSTEM" node - <<'EOF'
const fs = require('fs');
const path = process.env.NODE_ECOSYSTEM || '/home/coder/srv/pm2/ecosystem.config.js';
let mod = { apps: [] };
if (fs.existsSync(path)) { mod = require(path); }
mod.apps = (mod.apps || []).filter(a => a.name !== "__REPO__");
mod.apps.push({
  name: "__REPO__",
  script: "npm",
  args: "start",
  cwd: "__CWD__",
  env: { PORT: "__PORT__", BASE_PATH: "/__REPO__" },
  max_memory_restart: "250M",
  instances: 1,
  exec_mode: "fork",
  restart_delay: 2000
});
fs.writeFileSync(path, "module.exports=" + JSON.stringify(mod, null, 2));
EOF
# replace placeholders
sed -i "s#__REPO__#${REPO_NAME}#g;s#__CWD__#${APP_DIR}#g;s#__PORT__#${PORT}#g" "$ECOSYSTEM"

# reload services
nginx -t
nginx -s reload || nginx -s reopen

pm2 start "$ECOSYSTEM"
pm2 reload "${REPO_NAME}" || true
pm2 save
</file>

<file path="srv/docs/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0"
    >
    <title>PaaS Server for NodeJS Apps</title>
</head>

<body>
    <h1>PaaS Server for NodeJS Apps</h1>
    <p>Powered by PM2 and NGINX</p>
</body>

</html>
</file>

<file path="srv/pm2/ecosystem.config.js">
// /srv/pm2/ecosystem.config.js
module.exports = {
    apps: [
        {
            name: "webhook",
            script: "node",
            args: "/home/coder/srv/webhook/server.js",
            env: {
                WEBHOOK_PORT: "4600"
            }
        }

        // Entries appended by deploy script, e.g.:
        // {
        //   name: "repo-name",
        //   script: "npm",
        //   args: "start",
        //   cwd: "/srv/apps/repo-name",
        //   env: {
        //     PORT: 3001,
        //     BASE_PATH: "/repo-name"
        //   },
        //   max_memory_restart: "250M",
        //   instances: 1,
        //   exec_mode: "fork",
        //   restart_delay: 2000
        // }
    ]
}
</file>

<file path="srv/webhook/package.json">
{
    "name": "webhook",
    "private": true,
    "dependencies": {
        "express": "^4.21.2"
    }
}
</file>

<file path="coder/main.tf">
terraform {
  required_providers {
    coder = {
      source = "coder/coder"
    }
    kubernetes = {
      source = "hashicorp/kubernetes"
    }
  }
}

# Setup Variables
# username is a shorthand for the owner.
# ixd_domain (is probably ixdcoder.com or sheridanixd.com)
# workspace_slug - 8 pseudo random characters derived from the id of the workspace
# this is used as part of the editor URL and makes it  difficult guess 
# note you could make this longer but  a subdomain string cannot be longer than 63 characters 
# so it is good to leave some space for the actual name of the project.

locals {
  username = data.coder_workspace_owner.me.name
  ixd_domain = "ixdcoder.com"
  workspace_slug = substr(md5(data.coder_workspace.me.id), 0, 8)
}

provider "coder" {
}

variable "use_kubeconfig" {
  type        = bool
  description = <<-EOF
  Use host kubeconfig? (true/false)

  Set this to false if the Coder host is itself running as a Pod on the same
  Kubernetes cluster as you are deploying workspaces to.

  Set this to true if the Coder host is running outside the Kubernetes cluster
  for workspaces.  A valid "~/.kube/config" must be present on the Coder host.
  EOF
  default     = false
}

variable "namespace" {
  type        = string
  description = "The Kubernetes namespace to create workspaces in (must exist prior to creating workspaces). If the Coder host is itself running as a Pod on the same Kubernetes cluster as you are deploying workspaces to, set this to the same namespace."
}
 
 

data "coder_parameter" "git_repo" {
  name                = "git_repo"
  display_name        = "App #1 Git Repository"
  description = "URL for a Git Repository to deploy as a NodeJS app."
  icon        = "/icon/git.svg"
  type        = "string"
  mutable     = true
  default     = "https://bender.sheridanc.on.ca/sikkemha/nodejs.git" 
}
data "coder_parameter" "allowed_repos" {
  name         = "ALLOWED_REPOS"
  display_name = "Allowed GitHub repos (owner/repo)"
  type         = "list(string)"
  mutable      = true
  default      = jsonencode([
    "https://github.com/nsitu/express-hello-world"
  ])
}
 
  

provider "kubernetes" {
  # Authenticate via ~/.kube/config or a Coder-specific ServiceAccount, depending on admin preferences
  config_path = var.use_kubeconfig == true ? "~/.kube/config" : null
}
 
data "coder_workspace" "me" {}

# NOTE: the workspace owner details were previously included in coder_workspace.owner
# but those params are now deprecated in favour of "coder_workspace_owner"
data "coder_workspace_owner" "me" {} 

resource "coder_agent" "main" {
  os                     = "linux"
  arch                   = "amd64" 
  startup_script         = replace(file("${path.module}/startup.sh"), "\r", "")
 
  # TEST: this may help to tell VS Code Desktop which folder to open
  dir  = "/home/coder"

  display_apps {
    vscode          = false
    vscode_insiders = false
    web_terminal    = false
    ssh_helper      = false
  }

   
  env = {
    GIT_AUTHOR_NAME     = "${data.coder_workspace_owner.me.name}"
    GIT_COMMITTER_NAME  = "${data.coder_workspace_owner.me.name}"
    GIT_AUTHOR_EMAIL    = "${data.coder_workspace_owner.me.email}"
    GIT_COMMITTER_EMAIL = "${data.coder_workspace_owner.me.email}" 
    GIT_REPO            = "${data.coder_parameter.git_repo.value}" 
    WORKSPACE_NAME      = "${data.coder_workspace.me.name}"
    WORKSPACE_ID        = "${data.coder_workspace.me.id}"
    PUBLIC_URL          = "https://public--main--${lower(data.coder_workspace.me.name)}--${local.username}.${local.ixd_domain}/"
    EDITOR_URL          = "https://${local.workspace_slug}--main--${lower(data.coder_workspace.me.name)}--${local.username}.${local.ixd_domain}/"
    SETTINGS_URL        = "https://${local.ixd_domain}/@${local.username}/${data.coder_workspace.me.name}"
    USERNAME            = "${local.username}"
    # TEMPLATE_MODE       = "${data.coder_parameter.template_mode.value}"
    PORT                = 8080   

    ALLOWED_REPOS          = "${data.coder_parameter.allowed_repos.value}" 
    DEFAULT_BRANCH         = "main" 

  }
 
 
} 
# NOTE coder modules are frequently updated. 
# note that version  = "1.0.30" refers to the entire module repo rather than the specific module
# you can see a complete history of module changes here:/
# https://github.com/coder/modules/compare/v1.0.6...v1.0.30
# See also, more specifically:
# https://github.com/coder/modules/commits/main/cursor
# https://github.com/coder/modules/commits/main/vscode-web

 

module "vscode-web" {
  source         = "registry.coder.com/modules/vscode-web/coder"
  version        = "1.0.30"
  agent_id       = coder_agent.main.id
  folder   = "/home/coder"
  # extensions     = ["github.copilot"]
  settings = {
      "workbench.colorTheme": "Default Dark Modern",
      "workbench.colorCustomizations": {
          "statusBar.background" : "#1A1A1A",
          "statusBar.noFolderBackground" : "#212121",
          "statusBar.debuggingBackground": "#263238"
      },
      "files.exclude": {
          "**/*.cache": true,
          "**/*.config": true,
          "**/*.local": true,
          "**/*.bashrc": true,
          "**/*.npm": true,
          "**/*filebrowser.db": true,
          "**/*lost+found": true,
          "**/*.bash_history": true,
          "**/*.vscode": true,
          "**/*.dotnet": true,
          "**/*.vscode-server": true,
          "**/*.wget-hsts": true
      },
      "workbench.startupEditor" : "readme",
      "security.workspace.trust.enabled": false,
      "editor.defaultFormatter": "esbenp.prettier-vscode",
      "codetogether.userName": "${local.username}",
      "remote.portsAttributes": {
          "0-65535":{
              "onAutoForward":"silent"
          }
      },
      "remote.SSH.remotePlatform": {
          "*.ixdcoder.com": "linux",
      }
  } 
  accept_license = true
}
 
  

resource "coder_app" "webapp" {
  agent_id     = coder_agent.main.id
  slug         = "public"
  display_name = "Public URL"
  url          = "http://localhost:8080"
  icon         = "https://bender.sheridanc.on.ca/sikkemha/svg-icons/-/raw/main/html.svg"
  subdomain    = true
  share        = "public"
  healthcheck {
    # Note: this health check assumes that LiveServer is running,
    # as indeed it should be based on startup.sh
    url       = "http://localhost:8080"
    interval  = 5
    threshold = 6
  }
}

 
# NOTE: the storage amount is hard coded to 1Gigabyte here
# this is different from the NodeJS workspace, where it is parameterized.
resource "kubernetes_persistent_volume_claim" "home" {
  metadata {
    name      = "coder-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}-home" 
    namespace = var.namespace
    labels = {
      "app.kubernetes.io/name"     = "coder-pvc"
      "app.kubernetes.io/instance" = "coder-pvc-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}" 
      "app.kubernetes.io/part-of"  = "coder"
      //Coder-specific labels.
      "com.coder.resource"       = "true"
      "com.coder.workspace.id"   = data.coder_workspace.me.id
      "com.coder.workspace.name" = data.coder_workspace.me.name
      "com.coder.user.id"        = data.coder_workspace_owner.me.id
      "com.coder.user.username"  = data.coder_workspace_owner.me.name
    }
    annotations = {
      "com.coder.user.email" = data.coder_workspace_owner.me.email
    }
  }
  wait_until_bound = false
  spec {
    access_modes = ["ReadWriteOnce"]
    resources {
      requests = {
        storage = "512Mi"
      }
    }
  }
}

resource "kubernetes_deployment" "main" {
  count = data.coder_workspace.me.start_count
  depends_on = [
    kubernetes_persistent_volume_claim.home
  ]
  wait_for_rollout = false
  metadata {
    name      = "coder-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}" 
    namespace = var.namespace
    labels = {
      "app.kubernetes.io/name"     = "coder-workspace"
      "app.kubernetes.io/instance" = "coder-workspace-${lower(data.coder_workspace_owner.me.name)}-${lower(data.coder_workspace.me.name)}"
      "app.kubernetes.io/part-of"  = "coder"
      "com.coder.resource"         = "true"
      "com.coder.workspace.id"     = data.coder_workspace.me.id
      "com.coder.workspace.name"   = data.coder_workspace.me.name
      "com.coder.user.id"          = data.coder_workspace_owner.me.id
      "com.coder.user.username"    = data.coder_workspace_owner.me.name
    }
    annotations = {
      "com.coder.user.email" = data.coder_workspace_owner.me.email
    }
  }

  spec {
    # replicas = data.coder_workspace.me.start_count
    replicas = 1
    selector {
      match_labels = {
        "app.kubernetes.io/name" = "coder-workspace"
      }
    }
    strategy {
      type = "Recreate"
    }

    template {
      metadata {
        labels = {
          "app.kubernetes.io/name" = "coder-workspace"
        }
      }
      spec {
        security_context {
          run_as_user = 1000
          fs_group    = 1000
        }

        container {
          name              = "dev"
          # image             = "codercom/enterprise-node:ubuntu"
          # image             = "nsitu/node-devenv-2024:latest"
          image  = "nsitu/coder-pm2-paas:latest"
          # Image Pull Policy: Always / IfNotPresent/ Never
          # see also: https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy 
          image_pull_policy = "Always"
          command           = ["sh", "-c", coder_agent.main.init_script]
          security_context {
            run_as_user = "1000"
          }
          # TODO: maybe it is convenient to inject other env variables here?
          env {
            name  = "CODER_AGENT_TOKEN"
            value = coder_agent.main.token
          }
          resources {
            requests = {
              "cpu"    = "250m"
              "memory" = "512Mi"
            }
            limits = {
              "cpu"    = "1000m"
              "memory" = "2Gi"
            }
          }
          volume_mount {
            # IMPORTANT the mount path determines which files are persisted 
            # ie. saved between restarts.  
            mount_path = "/home/coder"
            name       = "home"
            read_only  = false
          }
        }

        volume {
          name = "home"
          persistent_volume_claim {
            claim_name = kubernetes_persistent_volume_claim.home.metadata.0.name
            read_only  = false
          }
        }

        affinity {
          // This affinity attempts to spread out all workspace pods evenly across
          // nodes.
          pod_anti_affinity {
            preferred_during_scheduling_ignored_during_execution {
              weight = 1
              pod_affinity_term {
                topology_key = "kubernetes.io/hostname"
                label_selector {
                  match_expressions {
                    key      = "app.kubernetes.io/name"
                    operator = "In"
                    values   = ["coder-workspace"]
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
</file>

<file path="srv/nginx/nginx.conf">
# /home/coder/srv/nginx/nginx.conf
worker_processes 1;

# place the pid file somewhere you can write
pid /home/coder/srv/nginx/nginx.pid;

events { worker_connections 1024; }

http {
  sendfile on;
  include       /etc/nginx/mime.types; # Use system-wide mime.types

  default_type  application/octet-stream;

  # ▶ logs you can write
  access_log /home/coder/srv/nginx/access.log;
  error_log  /home/coder/srv/nginx/error.log;

  # ▶ temp paths you can write
  client_body_temp_path /home/coder/srv/nginx/tmp/client 1 2;
  proxy_temp_path       /home/coder/srv/nginx/tmp/proxy;
  fastcgi_temp_path     /home/coder/srv/nginx/tmp/fastcgi;
  uwsgi_temp_path       /home/coder/srv/nginx/tmp/uwsgi;
  scgi_temp_path        /home/coder/srv/nginx/tmp/scgi;

  # WS support
  map $http_upgrade $connection_upgrade { default upgrade; '' close; }

  # Useful when apps need original host/path
  proxy_set_header Host $host;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  server {
    listen 8080;

    # Documentation landing page
    location = / {
      root /home/coder/srv/docs;
      try_files /index.html =404;
    }
    # GitHub webhook for app deployments
    location = /__hook/github {
      proxy_pass http://127.0.0.1:4600/webhook/github;
      proxy_http_version 1.1;
      # optional hardening:
      if ($request_method != POST) { return 405; } 
    }


    # Normalize trailing slashes so /repo and /repo/ both work
    rewrite ^/([^/]+)$ /$1/ permanent;

    # Per-app routes live here:
    include /home/coder/srv/nginx/conf.d/*.conf;
  }
}
</file>

<file path="srv/webhook/server.js">
// /home/coder/srv/webhook/server.js
const express = require('express');
const { spawn } = require('child_process');

const app = express();
app.use(express.json({ type: '*/*' })); // GitHub sends various content-types

// ---------- helpers: parse + normalize ----------
function splitEnvList(raw) {
    if (!raw || typeof raw !== 'string') return [];
    // Try JSON first
    try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) return parsed.map(String);
    } catch {/* fall through */ }
    // CSV / newline fallback (mirrors Bash sed/tr transformations)
    return raw
        .replace(/^\s*\[/, '').replace(/\]\s*$/, '') // strip brackets if present
        .replace(/"/g, '')
        .split(/[, \n\r]+/) // commas or whitespace/newlines
        .map(s => s.trim())
        .filter(Boolean);
}

// Normalize any of: git@host:owner/repo(.git), https?://host/owner/repo(.git), owner/repo
// -> canonical: https://host/owner/repo  (owner/repo lowercased, host lowercased, no .git, no trailing slash)
function normalizeEntry(entry) {
    if (!entry || typeof entry !== 'string') return null;
    const s = entry.trim();

    // SSH form
    let m = s.match(/^git@([^:]+):([^/]+)\/([^/]+?)(?:\.git)?\/?$/i);
    if (m) {
        const host = m[1].toLowerCase();
        const owner = m[2].toLowerCase();
        const repo = m[3].replace(/\.git$/i, '').toLowerCase();
        return `https://${host}/${owner}/${repo}`;
    }

    // HTTP(S) form
    try {
        const u = new URL(s);
        const host = u.host.toLowerCase();
        const parts = u.pathname.replace(/\/+$/, '').split('/').filter(Boolean);
        if (parts.length >= 2) {
            const owner = parts[0].toLowerCase();
            const repo = parts[1].replace(/\.git$/i, '').toLowerCase();
            return `https://${host}/${owner}/${repo}`;
        }
    } catch {/* not a URL */ }

    // owner/repo short form -> assume github.com
    if (/^[^/\s]+\/[^/\s]+$/.test(s)) {
        const [owner, repoRaw] = s.split('/');
        const ownerLC = owner.toLowerCase();
        const repoLC = repoRaw.replace(/\.git$/i, '').toLowerCase();
        return `https://github.com/${ownerLC}/${repoLC}`;
    }

    return null;
}

// Build canonical from any GitHub push payload
function canonicalFromPayload(body) {
    const tryFields = [
        body?.repository?.html_url,
        body?.repository?.clone_url,
        body?.repository?.ssh_url,
        body?.repository?.full_name, // owner/repo
    ];
    for (const v of tryFields) {
        const canon = normalizeEntry(v);
        if (canon) return canon;
    }
    return null;
}

// ---------- config ----------
const RAW_ALLOWED = splitEnvList(process.env.ALLOWED_REPOS || '');
const ALLOWED_REPOS = Array.from(
    new Set(RAW_ALLOWED.map(normalizeEntry).filter(Boolean))
);

const DEPLOY = process.env.DEPLOY_SCRIPT || '/home/coder/srv/deploy/deploy.sh';
const DEPLOYED_SHAS = new Set(); // per-process de-dupe

console.log("Allowed repos (normalized):", ALLOWED_REPOS);

// ---------- deploy runner with per-repo lock ----------
function runDeploy(repoName, gitUrl, branch) {
    return new Promise((resolve, reject) => {
        const lock = spawn('bash', ['-lc', `
      set -e
      LOCK="/tmp/deploy_${repoName}.lock"
      exec 9>"$LOCK"
      flock -n 9 || { echo "busy"; exit 99; }
      "${DEPLOY}" "${repoName}" "${gitUrl}" "${branch}"
    `], { stdio: ['ignore', 'pipe', 'pipe'] });

        let out = '', err = '';
        lock.stdout.on('data', d => out += d.toString());
        lock.stderr.on('data', d => err += d.toString());
        lock.on('close', code => {
            if (code === 0) resolve(out || 'ok');
            else if (code === 99) reject(new Error('deploy-in-progress'));
            else reject(new Error(err || `deploy failed (${code})`));
        });
    });
}

// ---------- webhook ----------
app.post('/webhook/github', async (req, res) => {
    try {
        const event = req.get('x-github-event');
        if (event !== 'push') return res.status(202).json({ status: `ignored:${event}` });

        const canonical = canonicalFromPayload(req.body);
        const branchRef = req.body?.ref;                     // "refs/heads/main"
        const branch = branchRef ? branchRef.replace(/^refs\/heads\//, '') : 'main';
        const afterSha = req.body?.after;

        if (!canonical || !afterSha) {
            return res.status(400).json({ error: 'missing repo or sha' });
        }

        // Allowlist check (if empty, allow all for PoC)
        if (ALLOWED_REPOS.length && !ALLOWED_REPOS.includes(canonical)) {
            return res.status(403).json({ error: 'repo not allowed', repo: canonical });
        }

        if (DEPLOYED_SHAS.has(afterSha)) {
            return res.status(202).json({ status: 'ignored:duplicate' });
        }

        // Extract owner/repo from canonical for naming + SSH clone URL
        const u = new URL(canonical);
        const [owner, repo] = u.pathname.replace(/^\//, '').split('/');
        const repoName = repo;
        const gitUrl = `git@${u.host}:${owner}/${repo}.git`;

        await runDeploy(repoName, gitUrl, branch);
        DEPLOYED_SHAS.add(afterSha);
        return res.json({ status: 'deployed', repo: repoName, host: u.host, branch, sha: afterSha });
    } catch (e) {
        const code = e.message === 'deploy-in-progress' ? 429 : 500;
        return res.status(code).json({ error: e.message });
    }
});

const port = process.env.WEBHOOK_PORT || 4600;
app.listen(port, '127.0.0.1', () => {
    console.log(`webhook listening on ${port}`);
});
</file>

<file path="README.md">
# coder-pm2-paas
Docker image for Coder with PM2 Node and NGINX

# srv folder
this folder includes structure that is used to manage deployments 

# coder folder
this folder holds coder workspace configuration files
</file>

<file path="coder/startup.sh">
set -e
 
# Shell cosmetics
echo 'export PS1="\[\033[01;34m\]\w\[\033[00m\] $ "' >> ~/.bashrc

# Optional template fallback
if [ "${CODE_TEMPLATE:-}" = "default" ]; then
  GIT_REPO="https://bender.sheridanc.on.ca/sikkemha/html-css-js"
fi

# Snapshot
echo "======== System Snapshot $(date '+%a %b %d %Y, %I:%M%p') ========"
coder stat || true
echo "==============================================================="

# --- Persistent base path for everything ---
BASE="/home/coder/srv"
NGINX_CONF="$BASE/nginx/nginx.conf"

# Create base directories if they don't exist
sudo mkdir -p "$BASE" "$BASE"/{apps,deploy,docs,nginx/conf.d,pm2,webhook}
sudo mkdir -p "$BASE"/nginx/tmp/{client,proxy,fastcgi,uwsgi,scgi}
sudo chown -R coder:coder "$BASE"


# Seed from image once
if [ ! -f "$BASE/nginx/nginx.conf" ] && [ -d /opt/bootstrap/srv ]; then
  cp -r /opt/bootstrap/srv/* "$BASE"/
fi

# --- Install Express for webhook ---
cd "$BASE/webhook"
npm install --omit=dev

# --- SSH setup for git@ clones (optional) ---
if [ -n "${GIT_SSH_PRIVATE_KEY:-}" ]; then
  mkdir -p ~/.ssh && chmod 700 ~/.ssh
  printf '%s\n' "$GIT_SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519
  chmod 600 ~/.ssh/id_ed25519
fi

# Seed known_hosts from ALLOWED_REPOS (JSON array or CSV)
if [ -n "${ALLOWED_REPOS:-}" ]; then
  mkdir -p ~/.ssh && chmod 700 ~/.ssh

  # Remove wrapping brackets/quotes if JSON
  CLEANED=$(echo "$ALLOWED_REPOS" | sed 's/[][]//g' | tr -d '"' | tr ',' '\n')

  echo "$CLEANED" | while read -r entry; do
    entry=$(echo "$entry" | xargs) # trim
    [ -z "$entry" ] && continue

    # Normalize forms: git@host:owner/repo.git, https://host/owner/repo, owner/repo
    if [[ "$entry" =~ ^git@([^:]+): ]]; then
      host="${BASH_REMATCH[1]}"
    elif [[ "$entry" =~ ^https?://([^/]+)/ ]]; then
      host="${BASH_REMATCH[1]}"
    elif [[ "$entry" =~ ^[^/]+/[^/]+$ ]]; then
      host="github.com"
    else
      continue
    fi

    host=$(echo "$host" | tr '[:upper:]' '[:lower:]')
    echo "Seeding SSH known_hosts for $host"
    ssh-keyscan "$host" >> ~/.ssh/known_hosts 2>/dev/null || true
  done

  chmod 644 ~/.ssh/known_hosts 2>/dev/null || true
fi

# --- Nginx up ---
nginx -t -c "$NGINX_CONF" \
  && (nginx -s reload -c "$NGINX_CONF" || nginx -c "$NGINX_CONF") \
  || { echo "Nginx config error"; exit 1; }

# --- PM2 up & webhook ---
export PM2_HOME="${PM2_HOME:-$BASE/.pm2}"
if [ -f "$PM2_HOME/dump.pm2" ]; then pm2 resurrect || true; fi
if ! pm2 describe webhook >/dev/null 2>&1; then
  pm2 start "$BASE/pm2/ecosystem.config.js" --only webhook || pm2 start "$BASE/pm2/ecosystem.config.js"
fi
pm2 save || true

# --- Optional first-boot auto-deploy (demo) ---
if [ ! -s "$BASE/deploy/ports.map" ] && [ -n "${GIT_REPO:-}" ]; then
  REPO_NAME="$(basename -s .git "$(echo "$GIT_REPO" | sed 's#.*[:/]\([^/]*\)\.git$#\1#')")"
  "$BASE/deploy/deploy.sh" "$REPO_NAME" "$GIT_REPO" "${DEFAULT_BRANCH:-main}" || echo "initial deploy failed"
  pm2 save || true
fi

echo "Startup complete. Public URL: ${PUBLIC_URL}"
</file>

<file path="Dockerfile">
FROM ubuntu:noble

SHELL ["/bin/bash", "-c"]
ENV DEBIAN_FRONTEND=noninteractive

# Install packages
RUN apt-get update && \
    apt-get upgrade --yes --no-install-recommends --no-install-suggests && \
    apt-get install --yes --no-install-recommends --no-install-suggests \
    ca-certificates \
    bash \
    build-essential \ 
    curl \ 
    htop \
    jq \
    locales \
    man \
    pipx \
    python3 \
    python3-pip \
    software-properties-common \
    sudo \
    # systemd \
    # systemd-sysv \
    unzip \
    zip \
    vim \
    wget \
    net-tools \
    dnsutils \
    tzdata \
    rsync \ 
    openssh-client \
    lsof \
    util-linux \
    nginx && \ 
    # Install latest Git using their official PPA
    add-apt-repository ppa:git-core/ppa && \
    apt-get install --yes git \
    && rm -rf /var/lib/apt/lists/*


# Install whichever Node version is LTS 
RUN curl -sL https://deb.nodesource.com/setup_lts.x | bash -
RUN DEBIAN_FRONTEND="noninteractive" apt-get update -y && \
    apt-get install -y nodejs 

# Latest NPM 
RUN npm install -g npm@latest --verbose

# Install pm2
RUN npm install pm2 -g

# Generate the desired locale (en_US.UTF-8)
RUN locale-gen en_US.UTF-8

# Set Timezone
ENV TZ="America/Toronto"

# Make typing unicode characters in the terminal work.
ENV LANG=en_US.UTF-8
ENV LANGUAGE=en_US.UTF-8
ENV LC_ALL=en_US.UTF-8

# Remove the `ubuntu` user and add a user `coder` so that you're not developing as the `root` user
RUN userdel -r ubuntu && \
    useradd coder \
    --create-home \
    --shell=/bin/bash \ 
    --uid=1000 \
    --user-group && \
    echo "coder ALL=(ALL) NOPASSWD:ALL" >>/etc/sudoers.d/nopasswd

# Copy system files to seed the container
COPY --chown=coder:coder srv/ /opt/bootstrap/srv/

# Pre-seed GitHub known_hosts to avoid first-clone prompts (optional):
RUN mkdir -p /home/coder/.ssh && ssh-keyscan github.com >> /home/coder/.ssh/known_hosts && chown -R coder:coder /home/coder/.ssh

USER coder

# adds user's bin directory to PATH
RUN pipx ensurepath
</file>

</files>
